'''
    INVALID BLOCK 101 IN INODE 13 AT OFFSET 0
	INVALID INDIRECT BLOCK 101 IN INODE 13 AT OFFSET 12
	INVALID DOUBLE INDIRECT BLOCK 101 IN INODE 13 AT OFFSET 268
	INVALID TRIPLE INDIRECT BLOCK 101 IN INODE 13 AT OFFSET 65804
	RESERVED INDIRECT BLOCK 3 IN INODE 13 AT OFFSET 12
	RESERVED DOUBLE INDIRECT BLOCK 3 IN INODE 13 AT OFFSET 268
	RESERVED TRIPLE INDIRECT BLOCK 3 IN INODE 13 AT OFFSET 65804
	RESERVED BLOCK 3 IN INODE 13 AT OFFSET 0
    UNREFERENCED BLOCK 37
    ALLOCATED BLOCK 8 ON FREELIST
    DUPLICATE BLOCK 8 IN INODE 13 AT OFFSET 0
	DUPLICATE INDIRECT BLOCK 8 IN INODE 13 AT OFFSET 12
	DUPLICATE DOUBLE INDIRECT BLOCK 8 IN INODE 13 AT OFFSET 268
	DUPLICATE TRIPLE INDIRECT BLOCK 8 IN INODE 13 AT OFFSET 6580
    ALLOCATED INODE 2 ON FREELIST
	UNALLOCATED INODE 17 NOT ON FREELIST
    INODE 2 HAS 4 LINKS BUT LINKCOUNT IS 5
    INODE 17 HAS 0 LINKS BUT LINKCOUNT IS 1
    DIRECTORY INODE 2 NAME 'nullEntry' UNALLOCATED INODE 17
	DIRECTORY INODE 2 NAME 'bogusEntry' INVALID INODE 26
    DIRECTORY INODE 2 NAME '..' LINK TO INODE 11 SHOULD BE 2
	DIRECTORY INODE 11 NAME '.' LINK TO INODE 2 SHOULD BE 11

    possible errors block errors
        invalid
            block number < 0 or > block count
        reserved
            block number is used by boot block, sb, bgt, inode bitmap, block bitmap, or inode table
        unreferenced
            not referenced by any file but marked as allocated by bitmap
        allocated
            allocated to file but marked as free on bitmap
        duplicate
            used by more than two files

    inode errors
        if imode == 0 inode is free, else used
        allocated
            imode != 0 but marked as free on inode bitmap
        unallocated
            imode ==0 but marked as used on inode bitmap

    directory errors
        going to use inode number in DIRENTRY and link count in INODE
        incorrect links count
            number of dir_entry pointing to the inode is not the same as ilinkscount
        unallocated
            inode referenced in dir_entry is marked as free in inode bitmap
        invalid
            inode referenced in direntry is <0 or >mac inode number from SUPERBLOCK
        . is not pointing to current directory and .. is not pointing to the parent DIRECTORY

'''

'''
data block number psuedo code
max_block = sb.s_blocks_count
orig_block_bitmap = block_bit_map
create empty my_block_bitmap
reserved_bit_map = calc_reserved_bit_map()//block numbers used by boot block, sb, etc

for every inode
    if inode is not used
        continue

    for every data block in inode
        if blocknum < 0 or block num > max_block
            report invalid
        if block number in reserved bitmap
            report reserved
        if block number is free in original block bitmap
            report allocated
        if block number is marked as used in my block bitmap
            report duplicated

        mark block number as used in my block bitmap
'''

'''
for block in my block bitmap
    if(block number marked as used in original block bitmap && block number is free in my block bitmap)
        report unreferenced
'''

'''
inode errors psuedo code
original inode bitmap = inode bitmap
for every inode
    if inode imode != 0 and inode marked as free in orig inode bitmap
        report allocated
    else if inode imode == 0 and inode marked as used in original inode bitmap
        report unallocated
'''

'''
max inode = super block iniode count
create inode reference array
create inode parent array
for every inode
    if inode is not directory
        continue
    par_inode = inode.i_ino
    for every directory entry in inode
        child_ino = dir_entry.inode
        child_name = dir_entry.name
        if child_ino < 0 or child_ino > max_inode
            report invalid
        if child inode is free in inode_bitmap
            report unallocated
        if child name is '.' and child_ino != par_ino
            report current mismatch
        if child_name is not '.' and child name is not '..'
            inode_ref_array[child_ino]++
        inode_par_array[child_ino] = par_ino
'''

'''
for every inode
    par_ino = inode number of current dir
    if inode _ref_array[par_inode] != inode.i_links_count
        report inocrrect_link_count
    if(inode not directory)
        continue
    for every directory entry in inode
        child_ino = dir_entry.inode #inode number of each child entry in the current dir
        child_name = dir_entry.name
        if child_name is '..' && child_ino != inode_par_array[par_ino]
            report parrent_mismatch
'''
